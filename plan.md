План разработки приложения CoinMetric для Android
1. Обзор проекта

Название: CoinMetric
Платформа: Android (разработка в Android Studio)
Цель: Приложение для семейного планирования бюджета с локальной базой данных, синхронизацией через Firebase (с использованием Google аккаунта) и фокусом на удобном управлении расходами/доходами.
Технологии:
Язык: Kotlin (рекомендуется для современного Android-разработки).
Библиотеки: Room для локальной БД, Firebase Authentication и Realtime Database/Firestore для синхронизации, Coroutines/Flow для асинхронных операций, Navigation Component для навигации, Material Design для UI.
Дополнительно: Dagger/Hilt для DI, LiveData/ViewModel для MVVM архитектуры.

Архитектура: MVVM (Model-View-ViewModel) для разделения логики, UI и данных. Это обеспечит оптимизацию и тестируемость.
Дополнительный функционал (на усмотрение):
Уведомления о приближении к лимиту категории.
Поддержка нескольких валют с конвертацией (используя внешний API, если нужно, но с оффлайн-кэшем).
Экспорт отчётов в PDF/CSV.
Тёмная тема и доступность (Accessibility) для оптимизированного UI.


2. Требования и функции

Основные функции:
Семейный доступ: Авторизация через Google, синхронизация данных для нескольких пользователей в одной "семье" (группа в Firebase).
Категории: Предопределённые (еда, транспорт, развлечения) + пользовательские.
Лимиты по категориям: Установка месячных лимитов, отслеживание прогресса.
Постоянные платежи: Автоматическое добавление повторяющихся транзакций (ежемесячно/еженедельно).
Калькулятор в транзакциях: Встроенный калькулятор для расчёта суммы при добавлении транзакции.
Календарь: Просмотр транзакций по датам, с фильтрами.
Аналитический дэшборд: Главная страница с графиками (пироговая диаграмма расходов, линейный график баланса), сводкой по лимитам и общим балансом.

Дополнительные функции:
Отчёты: Генерация ежемесячных/годовых отчётов.
Поиск и фильтры: Поиск транзакций по ключевым словам, фильтры по категориям/датам.
Оффлайн-режим: Все операции работают локально, синхронизация при подключении.

Безопасность: Шифрование локальной БД (Room с SQLCipher), авторизация только через Google.

3. Шаги разработки (план действий)

Шаг 1: Настройка проекта
Создать новый проект в Android Studio с шаблоном "Empty Activity".
Добавить зависимости в build.gradle: Room, Firebase (Auth, Firestore), Navigation, Coroutines, Material Components.
Настроить Firebase: Создать проект в Firebase Console, подключить Google Sign-In, настроить Firestore для хранения семейных данных.
Инициализировать Git для версионного контроля.

Шаг 2: Реализация аутентификации и семейного доступа
Логика: Использовать Firebase Authentication для входа через Google. После входа проверять/создавать "семейную группу" в Firestore (документ с ID пользователя, содержащий список участников).
UI: Экран входа с кнопкой "Войти через Google". После входа - приглашение/присоединение к семье (диалог с вводом кода приглашения).
Синхронизация: При входе загружать данные из Firestore в локальную Room БД. Использовать Firebase listeners для реального времени обновлений.

Шаг 3: Настройка базы данных
Локальная БД: Room с сущностями (Entity): Transaction (id, amount, category, date, type: income/expense, recurring: boolean), Category (id, name, limit, currentSpent), User (id, name, familyId).
Синхронизация: Repository паттерн. Локальный Repo работает с Room DAO, Remote Repo - с Firestore. SyncManager класс для bidirectional sync (используя WorkManager для фоновой синхронизации при подключении).
Логика: При добавлении транзакции - сохранить локально, затем отправить в Firestore. Конфликты решать по timestamp (последний выигрывает).

Шаг 4: Реализация ключевых функций (логическая часть)
Категории и лимиты:
Логика: В ViewModel категории хранятся в Flow из Repo. Лимит - поле в Category. При добавлении транзакции обновлять currentSpent = sum(transactions in category for current month). Прогресс: (currentSpent / limit) * 100.
Дополнительно: Если >80% лимита - отправить уведомление (NotificationManager).

Постоянные платежи:
Логика: Флаг recurring в Transaction. WorkManager задача для ежемесячного добавления (на 1-е число). При запуске приложения проверять и добавлять пропущенные.

Калькулятор в транзакциях:
Логика: В диалоге добавления транзакции - EditText с кнопками калькулятора (простой: +, -, *, /). Парсить выражение с помощью exp4j библиотеки или встроенного eval.

Календарь:
Логика: Использовать CalendarView или библиотеку как MaterialDatePicker. Загружать транзакции по дате из Repo, отображать список ниже календаря.

Аналитический дэшборд:
Логика: На главной - ViewModel собирает данные: totalBalance = sum(income) - sum(expense), pieChartData = groupBy(category).sum(amount), lineChart = dailyBalance over month. Использовать MPAndroidChart для графиков.
Оптимизация: Кэшировать расчёты в ViewModel, обновлять по LiveData.


Шаг 5: Дизайн UI/UX (оптимизированный)
Общий стиль: Material 3 с динамическими цветами (из wallpaper). BottomNavigationView для основных экранов: Dashboard, Transactions, Calendar, Settings. Использовать ConstraintLayout для отзывчивости на разные экраны.
Оптимизация: RecyclerView для списков с DiffUtil для плавных обновлений. Lazy loading изображений/иконок категорий. Тёмная/светлая тема с автоматическим переключением.
Экраны:
Главная (Dashboard): CardView с балансом, PieChart расходов, ProgressBar для каждой категории (лимит), список топ-расходов. Swipe-to-refresh для синхронизации.
Транзакции: FAB для добавления, RecyclerView списка (с фильтрами: Spinner для категорий, DatePicker для дат). В карточке: сумма, категория, дата, иконка (цвет по типу).
Добавление транзакции: DialogFragment с полями: сумма (с калькулятором - кнопки под EditText), категория (Spinner), дата, тип (RadioButton), recurring (Switch). Валидация: не пустые поля.
Категории: Экран с RecyclerView, для каждой - имя, лимит (EditText), прогресс. Кнопка добавления новой.
Календарь: CalendarView сверху, список транзакций снизу. Клик на дату - фильтр списка.
Настройки: Семейный доступ (список пользователей, приглашения), экспорт отчётов (кнопка генерирует PDF с PdfDocument), смена валюты (Spinner с конвертацией по фиксированному курсу или API).

Доступность: ContentDescription для элементов, большие кнопки, контрастные цвета.

Шаг 6: Дополнительный функционал (реализация)
Уведомления: NotificationChannel для бюджета. Логика: В ViewModel проверять лимиты при обновлении, если >limit - buildNotification с PendingIntent на экран категории.
Мультивалюта: Добавить поле currency в Transaction/Category. Конвертер: Простая функция с hardcoded курсами (или интеграция с бесплатным API как CurrencyLayer via Retrofit, но с оффлайн-фолбеком).
Экспорт: Кнопка в настройках - генерировать CSV с помощью OpenCSV или PDF с PdfDocument, поделиться через Intent.

Шаг 7: Тестирование и оптимизация
Unit-тесты: JUnit для ViewModel/Repo (проверка расчётов лимитов, sync логики).
UI-тесты: Espresso для экранов (клик на кнопки, проверка текстов).
Оптимизация: Профилировать с Android Profiler (память/CPU). Использовать Paging 3 для больших списков транзакций. Минимизировать сетевые запросы (batch sync).
Безопасность: Тестировать оффлайн/онлайн сценарии, обработка ошибок (Toasts для неудач).
Релиз: Минимальный SDK 24 (Android 7.0), target 34. Подписать APK, протестировать на эмуляторе/устройствах.


4. Ожидаемые вызовы и решения

Синхронизация конфликтов: Использовать Firestore transactions для атомарных обновлений.
Производительность: Для дэшборда - асинхронные расчёты в Coroutines, чтобы не блокировать UI.
Локализация: Добавить strings.xml для русского/английского, форматирование дат/валют по locale.

Этот план охватывает полную разработку от старта до релиза. Общее время: 2-4 недели для одного разработчика, в зависимости от опыта.