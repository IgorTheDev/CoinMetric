# Логика синхронизации с Firebase

## Описание системы синхронизации

Система синхронизации обеспечивает двустороннюю синхронизацию между локальной базой данных (Room) и облачной базой данных (Firebase Firestore) для обеспечения согласованности данных между различными устройствами пользователя.

## Архитектура синхронизации

### 1. FirestoreSyncService
Основной класс, отвечающий за взаимодействие с Firebase Firestore:

- `pushSnapshot(accountEmail: String, snapshot: SyncSnapshot)` - отправляет локальные изменения в облако
- `pullSnapshot(accountEmail: String): SyncSnapshot` - получает все данные из облака
- `pullChanges(accountEmail: String, sinceEpochMillis: Long): SyncSnapshot` - получает только изменения с указанного времени

### 2. Модель данных в Firestore
Данные хранятся в виде иерархии:
```
budgets/{accountEmail}/
├── categories/
├── members/
├── transactions/
├── recurring/
├── invites/
├── limits/
└── changes/
```

Коллекция `changes` используется для отслеживания изменений и реализации инкрементальной синхронизации.

### 3. Журнал изменений (Change Log)
Для каждой сущности ведется журнал изменений в коллекции `changes`:
- `entityType` - тип сущности (CATEGORY, MEMBER, TRANSACTION и т.д.)
- `entityId` - ID сущности
- `updatedAtEpochMillis` - время последнего изменения
- `action` - действие (upsert, delete)
- `source` - источник (local, remote)

### 4. Состояние синхронизации (SyncState)
Хранится локально в таблице `SyncState`:
- `lastPulledAtEpochMillis` - время последней синхронизации получения
- `lastPushedAtEpochMillis` - время последней синхронизации отправки

### 5. Процесс синхронизации (GoogleSyncWorker)
Работник WorkManager выполняет синхронизацию по следующему алгоритму:

1. Получение изменений с сервера с момента последней синхронизации
2. Объединение (merge) изменений с локальной базой с разрешением конфликтов
3. Отправка локальных изменений на сервер
4. Обновление состояния синхронизации

### 6. Разрешение конфликтов
При конфликтах используется стратегия "last write wins" (LWW) - побеждает самое позднее изменение по времени обновления `updatedAtEpochMillis`.

## Типы сущностей, подлежащих синхронизации

1. **Категории (Category)** - названия и цвета категорий расходов
2. **Участники семьи (FamilyMember)** - имена, email и роли участников
3. **Транзакции (TransactionEntity)** - доходы и расходы
4. **Постоянные платежи (RecurringPayment)** - регулярные платежи
5. **Приглашения (CollaborationInvite)** - приглашения для совместного использования бюджета
6. **Лимиты (CategoryLimit)** - месячные лимиты по категориям

## Инкрементальная синхронизация

Для повышения эффективности используется инкрементальная синхронизация:
- Синхронизация только измененных записей с использованием курсоров времени
- Минимизация объема передаваемых данных
- Оптимизация сетевого трафика и времени выполнения

## Обработка ошибок

- При ошибках синхронизации возвращается `Result.retry()` для повторной попытки
- Обработка случаев отсутствия интернет-соединения
- Локальное хранение изменений до успешной синхронизации